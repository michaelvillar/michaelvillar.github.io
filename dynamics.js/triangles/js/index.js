// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  (function() {
    var DURATION_R, Triangle, Vertice, canvas, canvasHeight, canvasWidth, cellsX, cellsY, cellsizeX, cellsizeY, col, ctx, delaunayTriangles, draw, i, objectIndex, options, pastelColor, pixelRatio, randomBetween, row, triangle, triangles, vertice, vertices, verticesObjects, x, y, _fn, _i, _j, _k, _l, _len, _len1;
    DURATION_R = 1.4;
    canvas = document.querySelector('canvas');
    ctx = canvas.getContext("2d");
    pixelRatio = window.devicePixelRatio || 1;
    canvasWidth = parseInt(canvas.width, 10);
    canvasHeight = parseInt(canvas.height, 10);
    canvas.width = canvasWidth * pixelRatio;
    canvas.height = canvasHeight * pixelRatio;
    canvas.style.width = canvasWidth + "px";
    canvas.style.height = canvasHeight + "px";
    randomBetween = function(a, b) {
      return Math.round(a + Math.random() * (b - a));
    };
    pastelColor = function() {
      var b, g, r;
      r = randomBetween(80, 255);
      g = randomBetween(Math.max(80, 255 - r), 255);
      b = randomBetween(Math.max(80, 255 - Math.max(r, g)), 255);
      return [r, g, b];
    };
    objectIndex = 0;
    Vertice = (function() {

      function Vertice(_arg) {
        this.x = _arg[0], this.y = _arg[1];
        this[0] = this.x;
        this[1] = this.y;
      }

      Vertice.prototype.animateFrom = function(_arg) {
        var from, to, tween, x, y,
          _this = this;
        x = _arg[0], y = _arg[1];
        if (this.animating) {
          return;
        }
        this.animating = true;
        if (this[1] === 0) {
          y = 0;
        }
        from = [x, y];
        to = [this[0], this[1]];
        this[0] = x;
        this[1] = y;
        return tween = new Dynamics.Tween({
          type: Dynamics.Types.Spring,
          duration: 1000 * DURATION_R,
          friction: 400,
          change: function(t, value) {
            _this[0] = from[0] + (value * (to[0] - from[0]));
            return _this[1] = from[1] + (value * (to[1] - from[1]));
          }
        }).start();
      };

      return Vertice;

    })();
    Triangle = (function() {

      function Triangle(a, b, c) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.leftX = __bind(this.leftX, this);

        this.show = __bind(this.show, this);

        this.fill = __bind(this.fill, this);

        this.draw = __bind(this.draw, this);

        this.alpha = 1;
        this.color = pastelColor();
        this.index = objectIndex;
        objectIndex += 1;
      }

      Triangle.prototype.draw = function(ctx) {
        this.fill(ctx, "white");
        return this.fill(ctx, "rgba(" + this.color[0] + "," + this.color[1] + "," + this.color[2] + "," + (0.16 * this.alpha) + ")");
      };

      Triangle.prototype.fill = function(ctx, color) {
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.moveTo(this.a[0] * pixelRatio, this.a[1] * pixelRatio);
        ctx.lineTo(this.b[0] * pixelRatio, this.b[1] * pixelRatio);
        ctx.lineTo(this.c[0] * pixelRatio, this.c[1] * pixelRatio);
        return ctx.fill();
      };

      Triangle.prototype.show = function() {
        var fromPoint, p, point, tween, _i, _len, _ref,
          _this = this;
        fromPoint = this.b;
        point = this.a;
        if (this.b[0] > point[0]) {
          point = this.b;
          fromPoint = this.a;
        }
        if (this.c[0] > point[0]) {
          point = this.c;
        }
        _ref = [this.a, this.b, this.c];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          if (p[0] !== 0) {
            p.animateFrom([p[0] - 100, p[1]]);
          }
        }
        return tween = new Dynamics.Tween({
          type: Dynamics.Types.EaseInOut,
          duration: 100 * DURATION_R,
          change: function(t, value) {
            return _this.alpha = value;
          }
        }).start();
      };

      Triangle.prototype.leftX = function() {
        return Math.min(this.a[0], this.b[0], this.c[0]);
      };

      return Triangle;

    })();
    options = {
      cellsize: 27,
      cellpadding: 40
    };
    cellsX = Math.ceil(canvasWidth / options.cellsize - 1);
    cellsY = Math.ceil(canvasHeight / options.cellsize - 1);
    cellsizeX = canvasWidth / cellsX;
    cellsizeY = canvasHeight / cellsY;
    triangles = [];
    vertices = [];
    for (col = _i = 0; 0 <= cellsX ? _i <= cellsX : _i >= cellsX; col = 0 <= cellsX ? ++_i : --_i) {
      for (row = _j = 0; 0 <= cellsY ? _j <= cellsY : _j >= cellsY; row = 0 <= cellsY ? ++_j : --_j) {
        if (col === 0) {
          x = 0;
        } else if (col === cellsX) {
          x = canvasWidth;
        } else {
          x = col * cellsizeX + Math.random() * options.cellpadding;
        }
        if (row === 0) {
          y = 0;
        } else if (row === cellsY) {
          y = canvasHeight;
        } else {
          y = row * cellsizeY + Math.random() * options.cellpadding;
        }
        vertices.push([x, y]);
      }
    }
    delaunayTriangles = Delaunay.triangulate(vertices);
    verticesObjects = [];
    for (_k = 0, _len = vertices.length; _k < _len; _k++) {
      vertice = vertices[_k];
      verticesObjects.push(new Vertice(vertice));
    }
    i = 0;
    while (i < delaunayTriangles.length) {
      triangle = new Triangle(verticesObjects[delaunayTriangles[i]], verticesObjects[delaunayTriangles[i + 1]], verticesObjects[delaunayTriangles[i + 2]]);
      triangle.alpha = 0;
      triangles.push(triangle);
      i += 3;
    }
    draw = function() {
      var _l, _len1;
      ctx.clearRect(0, 0, canvasWidth * pixelRatio, canvasHeight * pixelRatio);
      for (_l = 0, _len1 = triangles.length; _l < _len1; _l++) {
        triangle = triangles[_l];
        triangle.draw(ctx);
      }
      return requestAnimationFrame(draw);
    };
    i = triangles.length;
    _fn = function(triangle, i) {
      return setTimeout(function() {
        return triangle.show();
      }, i * 2 * DURATION_R);
    };
    for (_l = 0, _len1 = triangles.length; _l < _len1; _l++) {
      triangle = triangles[_l];
      i -= 1;
      _fn(triangle, i);
    }
    draw();
    return requestAnimationFrame(draw);
  })();

}).call(this);
